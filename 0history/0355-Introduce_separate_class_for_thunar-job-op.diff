diff --git a/docs/reference/thunar/thunar-docs.xml b/docs/reference/thunar/thunar-docs.xml
index a0d106be..33cd1546 100644
--- a/docs/reference/thunar/thunar-docs.xml
+++ b/docs/reference/thunar/thunar-docs.xml
@@ -55,7 +55,7 @@
   <!ENTITY ThunarSessionClient SYSTEM "xml/thunar-session-client.xml">
   <!ENTITY ThunarShortcutsPane SYSTEM "xml/thunar-shortcuts-pane.xml">
   <!ENTITY ThunarJob SYSTEM "xml/thunar-job.xml">
-  <!ENTITY ThunarJobOperation SYSTEM "xml/thunar-job-operation.xml">
+  <!ENTITY ThunarJobOperation SYSTEM "xml/thunar-job-operation-history.xml">
   <!ENTITY ThunarPangoExtensions SYSTEM "xml/thunar-pango-extensions.xml">
   <!ENTITY ThunarStatusbar SYSTEM "xml/thunar-statusbar.xml">
   <!ENTITY ThunarLocationBar SYSTEM "xml/thunar-location-bar.xml">
@@ -150,7 +150,7 @@
       <xi:include href="xml/thunar-enum-types.xml"/>
       <xi:include href="xml/thunar-preferences.xml"/>
       <xi:include href="xml/thunar-user.xml"/>
-      <xi:include href="xml/thunar-job-operation.xml"/>
+      <xi:include href="xml/thunar-job-operation-history.xml"/>
     </chapter>
   </part>
 
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 6a782928..4f31049e 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -39,6 +39,7 @@ thunar/thunar-io-jobs-util.c
 thunar/thunar-io-scan-directory.c
 thunar/thunar-job.c
 thunar/thunar-job-operation.c
+thunar/thunar-job-operation-history.c
 thunar/thunar-list-model.c
 thunar/thunar-location-bar.c
 thunar/thunar-location-button.c
diff --git a/thunar/Makefile.am b/thunar/Makefile.am
index db4c66b8..bb6d3848 100644
--- a/thunar/Makefile.am
+++ b/thunar/Makefile.am
@@ -123,6 +123,8 @@ thunar_SOURCES =							\
 	thunar-job.h							\
 	thunar-job-operation.c						\
 	thunar-job-operation.h						\
+	thunar-job-operation-history.c						\
+	thunar-job-operation-history.h						\
 	thunar-list-model.c						\
 	thunar-list-model.h						\
 	thunar-location-bar.c						\
diff --git a/thunar/thunar-application.h b/thunar/thunar-application.h
index 00b34ffd..fee97f8f 100644
--- a/thunar/thunar-application.h
+++ b/thunar/thunar-application.h
@@ -23,7 +23,7 @@
 #ifndef __THUNAR_APPLICATION_H__
 #define __THUNAR_APPLICATION_H__
 
-#include <thunar/thunar-job-operation.h>
+#include <thunar/thunar-job-operation-history.h>
 #include <thunar/thunar-window.h>
 #include <thunar/thunar-thumbnail-cache.h>
 
diff --git a/thunar/thunar-io-jobs.c b/thunar/thunar-io-jobs.c
index e15fe9fa..7d28833d 100644
--- a/thunar/thunar-io-jobs.c
+++ b/thunar/thunar-io-jobs.c
@@ -295,7 +295,7 @@ _thunar_io_jobs_create (ThunarJob  *job,
 
   if (log_mode == THUNAR_OPERATION_LOG_OPERATIONS)
     {
-      thunar_job_operation_commit (operation);
+      thunar_job_operation_history_commit (operation);
       g_object_unref (operation);
     }
 
@@ -458,7 +458,7 @@ _thunar_io_jobs_mkdir (ThunarJob  *job,
 
   if (log_mode == THUNAR_OPERATION_LOG_OPERATIONS)
     {
-      thunar_job_operation_commit (operation);
+      thunar_job_operation_history_commit (operation);
       g_object_unref (operation);
     }
 
@@ -836,7 +836,7 @@ _thunar_io_jobs_link (ThunarJob  *job,
 
   if (log_mode == THUNAR_OPERATION_LOG_OPERATIONS)
     {
-      thunar_job_operation_commit (operation);
+      thunar_job_operation_history_commit (operation);
       g_object_unref (operation);
     }
 
@@ -937,13 +937,13 @@ _thunar_io_jobs_trash (ThunarJob  *job,
 
   if (log_mode == THUNAR_OPERATION_LOG_OPERATIONS)
     {
-      thunar_job_operation_commit (operation);
+      thunar_job_operation_history_commit (operation);
       g_object_unref (operation);
     }
   else if (log_mode == THUNAR_OPERATION_LOG_ONLY_TIMESTAMPS)
     {
       /* only required for 'redo' operation, in order to update the timestamps of the original trash operation */
-      thunar_job_operation_update_trash_timestamps (operation);
+      thunar_job_operation_history_update_trash_timestamps (operation);
       g_object_unref (operation);
     }
 
@@ -1419,7 +1419,7 @@ _thunar_io_jobs_rename (ThunarJob  *job,
         {
           operation = thunar_job_operation_new (THUNAR_JOB_OPERATION_KIND_RENAME);
           thunar_job_operation_add (operation, g_file_new_for_uri (old_file_uri), thunar_file_get_file (file));
-          thunar_job_operation_commit (operation);
+          thunar_job_operation_history_commit (operation);
           g_object_unref (operation);
         }
     }
diff --git a/thunar/thunar-job-operation-history.c b/thunar/thunar-job-operation-history.c
new file mode 100644
index 00000000..24a00392
--- /dev/null
+++ b/thunar/thunar-job-operation-history.c
@@ -0,0 +1,407 @@
+/* vi:set et ai sw=2 sts=2 ts=2: */
+/*-
+ * Copyright (c) 2022 Alexander Schwinn <alexxcons@xfce.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <thunar/thunar-dialogs.h>
+#include <thunar/thunar-enum-types.h>
+#include <thunar/thunar-job-operation-history.h>
+#include <thunar/thunar-notify.h>
+#include <thunar/thunar-preferences.h>
+#include <thunar/thunar-private.h>
+#include <libxfce4ui/libxfce4ui.h>
+
+/**
+ * SECTION:thunar-job-operation-history
+ * @Short_description: Manages the logging of job operations (copy, move etc.) and undoing and redoing them
+ * @Title: ThunarJobOperationHistory
+ *
+ * The single #ThunarJobOperationHistory instance stores all job operations in a #GList
+ * and manages tools to manage the list and the next/previous operations which can be undone/redone */
+
+static void thunar_job_operation_history_finalize (GObject *object);
+
+
+
+struct _ThunarJobOperationHistory
+{
+  GObject  __parent__;
+
+  /* List of job operations which were logged */
+  GList   *job_operation_list;
+  gint     job_operation_list_max_size;
+
+  /* List pointer to the operation which can be undone */
+  GList   *lp_undo;
+
+  /* List pointer to the operation which can be redone */
+  GList   *lp_redo;
+};
+
+static ThunarJobOperationHistory *job_operation_history;
+
+G_DEFINE_TYPE (ThunarJobOperationHistory, thunar_job_operation_history, G_TYPE_OBJECT)
+
+
+
+static void
+thunar_job_operation_history_class_init (ThunarJobOperationHistoryClass *klass)
+{
+  GObjectClass      *gobject_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = thunar_job_operation_history_finalize;
+}
+
+
+
+static void
+thunar_job_operation_history_init (ThunarJobOperationHistory *self)
+{
+  ThunarPreferences *preferences;
+
+  self->job_operation_list = NULL;
+  self->lp_undo = NULL;
+  self->lp_redo = NULL;
+
+  preferences = thunar_preferences_get ();
+  g_object_get (G_OBJECT (preferences), "misc-undo-redo-history-size", &(self->job_operation_list_max_size), NULL);
+  g_object_unref (preferences);
+}
+
+
+
+static void
+thunar_job_operation_history_finalize (GObject *object)
+{
+  ThunarJobOperationHistory *history = THUNAR_JOB_OPERATION_HISTORY (object);
+
+  _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION_HISTORY (history));
+
+  g_list_free_full (history->job_operation_list, g_object_unref);
+
+  (*G_OBJECT_CLASS (thunar_job_operation_history_parent_class)->finalize) (object);
+}
+
+
+
+/**
+ * thunar_job_operation_history_get_default:
+ *
+ * Returns a reference to the default #ThunarJobOperationHistory
+ * instance.
+ *
+ * The caller is responsible to free the returned instance
+ * using g_object_unref() when no longer needed.
+ *
+ * Return value: the default #ThunarJobOperationHistory instance.
+ **/
+ThunarJobOperationHistory*
+thunar_job_operation_history_get_default (void)
+{
+  if (G_UNLIKELY (job_operation_history == NULL))
+    {
+      /* allocate the default monitor */
+      job_operation_history = g_object_new (THUNAR_TYPE_JOB_OPERATION_HISTORY, NULL);
+      g_object_add_weak_pointer (G_OBJECT (job_operation_history),
+                                 (gpointer) &job_operation_history);
+    }
+  else
+    {
+      /* take a reference for the caller */
+      g_object_ref (G_OBJECT (job_operation_history));
+    }
+
+  return job_operation_history;
+}
+
+
+
+/**
+ * thunar_job_operation_history_commit:
+ * @job_operation: a #ThunarJobOperation
+ *
+ * Commits, or registers, the given thunar_job_operation, adding the job operation
+ * to the job operation list.
+ **/
+void
+thunar_job_operation_history_commit (ThunarJobOperation *job_operation)
+{
+  _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION (job_operation));
+
+  if (thunar_job_operation_get_kind (job_operation) == THUNAR_JOB_OPERATION_KIND_TRASH)
+    {
+      /* set the timestamp for the operation, in seconds. g_get_real_time gives
+       * us the time in microseconds, so we need to divide by 1e6. */
+      thunar_job_operation_set_end_timestamp (job_operation, g_get_real_time () / (gint64) 1e6);
+    }
+
+  /* When a new operation is added, drop all previous operations which where undone from the list */
+  if (job_operation_history->lp_redo != NULL)
+    {
+      GList* new_list = NULL;
+      for (GList* lp = job_operation_history->job_operation_list;
+          lp != NULL && lp != job_operation_history->lp_redo;
+          lp = lp->next)
+        new_list = g_list_append (new_list, g_object_ref (lp->data));
+      g_list_free_full (job_operation_history->job_operation_list, g_object_unref);
+      job_operation_history->job_operation_list = new_list;
+    }
+
+  /* Add the new operation to our list */
+  job_operation_history->job_operation_list = g_list_append (job_operation_history->job_operation_list, g_object_ref (job_operation));
+
+  /* reset the undo pointer to latest operation and clear the redo pointer */
+  job_operation_history->lp_undo = g_list_last (job_operation_history->job_operation_list);
+  job_operation_history->lp_redo = NULL;
+
+  /* Limit the size of the list */
+  if (job_operation_history->job_operation_list_max_size != -1 && g_list_length (job_operation_history->job_operation_list) > (guint)(job_operation_history->job_operation_list_max_size))
+    {
+      GList* first = g_list_first (job_operation_history->job_operation_list);
+      job_operation_history->job_operation_list = g_list_remove_link (job_operation_history->job_operation_list, first);
+      g_list_free_full (first, g_object_unref);
+    }
+}
+
+
+
+/**
+ * thunar_job_operation_history_update_trash_timestamps:
+ * @job_operation: a #ThunarJobOperation
+ *
+ * Only updates the timestamps of the latest trash operation
+ * That is needed after 'redo' of a 'trash' operation,
+ * since it requires to set new timestamps (otherwise 'undo' of that operation wont work afterwards)
+ **/
+void
+thunar_job_operation_history_update_trash_timestamps (ThunarJobOperation *job_operation)
+{
+  _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION (job_operation));
+
+  if (thunar_job_operation_get_kind (job_operation) != THUNAR_JOB_OPERATION_KIND_TRASH)
+    return;
+
+  if (job_operation_history->lp_undo == NULL)
+    return;
+
+  if (thunar_job_operation_compare ( THUNAR_JOB_OPERATION (job_operation_history->lp_undo->data), job_operation) == 0)
+    {
+      gint64 start_timestamp, end_timestamp;
+
+      thunar_job_operation_get_timestamps (job_operation, &start_timestamp, &end_timestamp);
+
+      /* set the timestamp for the operation, in seconds. g_get_real_time gives
+       * us the time in microseconds, so we need to divide by 1e6. */
+      end_timestamp = g_get_real_time () / (gint64) 1e6;
+
+      thunar_job_operation_set_start_timestamp (THUNAR_JOB_OPERATION (job_operation_history->lp_undo->data), start_timestamp);
+      thunar_job_operation_set_end_timestamp (THUNAR_JOB_OPERATION (job_operation_history->lp_undo->data), end_timestamp);
+    }
+}
+
+
+
+/**
+ * thunar_job_operation_history_undo:
+ *
+ * Undoes the latest job operation, by executing its inverse
+ **/
+void
+thunar_job_operation_history_undo (void)
+{
+  ThunarJobOperation *operation_marker;
+  ThunarJobOperation *inverted_operation;
+  GString            *warning_body;
+  gchar              *file_uri;
+  GError             *err = NULL;
+  const GList        *overwritten_files;
+
+  /* Show a warning in case there is no operation to undo */
+  if (job_operation_history->lp_undo == NULL)
+    {
+      xfce_dialog_show_warning (NULL,
+                                _("No operation which can be undone has been performed yet.\n"
+                                  "(For some operations undo is not supported)"),
+                                _("There is no operation to undo"));
+      return;
+    }
+
+  /* the 'marked' operation */
+  operation_marker = job_operation_history->lp_undo->data;
+
+  /* fix position undo/redo pointers */
+  job_operation_history->lp_redo = job_operation_history->lp_undo;
+  job_operation_history->lp_undo = g_list_previous (job_operation_history->lp_undo);
+
+  /* warn the user if the previous operation is empty, since then there is nothing to undo */
+  if (thunar_job_operation_empty (operation_marker))
+    {
+
+      xfce_dialog_show_warning (NULL,
+                                _("The operation you are trying to undo does not have any files "
+                                  "associated with it, and thus cannot be undone. "),
+                                _("%s operation cannot be undone"), thunar_job_operation_get_kind_nick (operation_marker));
+      return;
+    }
+
+    /* if there were files overwritten in the operation, warn about them */
+    overwritten_files = thunar_job_operation_get_overwritten_files (operation_marker);
+    if (overwritten_files != NULL)
+      {
+        gint index;
+
+        index = 1; /* one indexed for the dialog */
+        warning_body = g_string_new (_("The following files were overwritten in the operation "
+                                       "you are trying to undo and cannot be restored:\n"));
+
+        for (const GList *lp = overwritten_files; lp != NULL; lp = lp->next, index++)
+          {
+            file_uri = g_file_get_uri (lp->data);
+            g_string_append_printf (warning_body, "%d. %s\n", index, file_uri);
+            g_free (file_uri);
+          }
+
+        xfce_dialog_show_warning (NULL,
+                                  warning_body->str,
+                                  _("%s operation can only be partially undone"),
+                                  thunar_job_operation_get_kind_nick (operation_marker));
+
+        g_string_free (warning_body, TRUE);
+      }
+
+    inverted_operation = thunar_job_operation_new_invert (operation_marker);
+    thunar_job_operation_execute (inverted_operation, &err);
+    g_object_unref (inverted_operation);
+
+    if (err == NULL)
+      thunar_notify_undo (operation_marker);
+}
+
+
+
+/**
+ * thunar_job_operation_history_redo:
+ *
+ * Redoes the last job operation which had been undone (if any)
+ **/
+void
+thunar_job_operation_history_redo (void)
+{
+  ThunarJobOperation *operation_marker;
+  GString            *warning_body;
+  gchar              *file_uri;
+  GError             *err = NULL;
+  const GList        *overwritten_files;
+
+  /* Show a warning in case there is no operation to undo */
+  if (job_operation_history->lp_redo == NULL)
+    {
+      xfce_dialog_show_warning (NULL,
+                                _("No operation which can be redone available.\n"),
+                                _("There is no operation to redo"));
+      return;
+    }
+
+  /* the 'marked' operation */
+  operation_marker = job_operation_history->lp_redo->data;
+
+  /* fix position undo/redo pointers */
+  job_operation_history->lp_undo = job_operation_history->lp_redo;
+  job_operation_history->lp_redo = g_list_next (job_operation_history->lp_redo);
+
+  /* warn the user if the previous operation is empty, since then there is nothing to undo */
+  if (thunar_job_operation_empty (operation_marker))
+    {
+
+      xfce_dialog_show_warning (NULL,
+                                _("The operation you are trying to redo does not have any files "
+                                  "associated with it, and thus cannot be redone. "),
+                                _("%s operation cannot be redone"), thunar_job_operation_get_kind_nick (operation_marker));
+      return;
+    }
+
+    /* if there were files overwritten in the operation, warn about them */
+    overwritten_files = thunar_job_operation_get_overwritten_files (operation_marker);
+    if (overwritten_files != NULL)
+      {
+        gint index;
+
+        index = 1; /* one indexed for the dialog */
+        warning_body = g_string_new (_("The following files were overwritten in the operation "
+                                       "you are trying to redo and cannot be restored:\n"));
+
+        for (const GList *lp = overwritten_files; lp != NULL; lp = lp->next, index++)
+          {
+            file_uri = g_file_get_uri (lp->data);
+            g_string_append_printf (warning_body, "%d. %s\n", index, file_uri);
+            g_free (file_uri);
+          }
+
+        xfce_dialog_show_warning (NULL,
+                                  warning_body->str,
+                                  _("%s operation can only be partially redone"),
+                                  thunar_job_operation_get_kind_nick (operation_marker));
+
+        g_string_free (warning_body, TRUE);
+      }
+
+    thunar_job_operation_execute (operation_marker, &err);
+
+    if (err == NULL)
+      thunar_notify_redo (operation_marker);
+}
+
+
+
+/* thunar_job_operation_history_can_undo:
+ *
+ * Returns whether or not there is an operation on the job operation list that can be undone.
+ *
+ * Return value: A gboolean representing whether or not there is an undoable operation
+ **/
+gboolean
+thunar_job_operation_history_can_undo (void)
+{
+  if (job_operation_history->lp_undo == NULL)
+    return FALSE;
+ 
+  if (thunar_job_operation_empty (job_operation_history->lp_undo->data))
+    return FALSE;
+
+  return TRUE;
+}
+
+
+
+/* thunar_job_operation_history_can_redo:
+ *
+ * Returns whether or not there is an operation on the job operation list that can be redone.
+ *
+ * Return value: A gboolean representing whether or not there is an redoable operation
+ **/
+gboolean
+thunar_job_operation_history_can_redo (void)
+{
+  if (job_operation_history->lp_redo == NULL)
+    return FALSE;
+
+  if (thunar_job_operation_empty (job_operation_history->lp_redo->data))
+    return FALSE;
+
+  return TRUE;
+}
+
diff --git a/thunar/thunar-job-operation-history.h b/thunar/thunar-job-operation-history.h
new file mode 100644
index 00000000..3ff08b97
--- /dev/null
+++ b/thunar/thunar-job-operation-history.h
@@ -0,0 +1,40 @@
+/* vi:set et ai sw=2 sts=2 ts=2: */
+/*-
+ * Copyright (c) 2022 Alexander Schwinn <alexxcons@xfce.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __THUNAR_JOB_OPERATION_HISTORY_H__
+#define __THUNAR_JOB_OPERATION_HISTORY_H__
+
+#include <glib.h>
+#include <thunar-job-operation.h>
+
+G_BEGIN_DECLS
+
+#define THUNAR_TYPE_JOB_OPERATION_HISTORY (thunar_job_operation_history_get_type ())
+G_DECLARE_FINAL_TYPE (ThunarJobOperationHistory, thunar_job_operation_history, THUNAR, JOB_OPERATION_HISTORY, GObject)
+
+ThunarJobOperationHistory* thunar_job_operation_history_get_default             (void);
+void                       thunar_job_operation_history_commit                  (ThunarJobOperation    *job_operation);
+void                       thunar_job_operation_history_update_trash_timestamps (ThunarJobOperation    *job_operation);
+void                       thunar_job_operation_history_undo                    (void);
+void                       thunar_job_operation_history_redo                    (void);
+gboolean                   thunar_job_operation_history_can_undo                (void);
+gboolean                   thunar_job_operation_history_can_redo                (void);
+
+G_END_DECLS
+
+#endif /* __THUNAR_JOB_OPERATION_HISTORY_H__ */
diff --git a/thunar/thunar-job-operation.c b/thunar/thunar-job-operation.c
index 2dcbbe79..bb3e68b6 100644
--- a/thunar/thunar-job-operation.c
+++ b/thunar/thunar-job-operation.c
@@ -17,37 +17,23 @@
  */
 
 #include <thunar/thunar-application.h>
-#include <thunar/thunar-dialogs.h>
-#include <thunar/thunar-enum-types.h>
 #include <thunar/thunar-io-jobs.h>
 #include <thunar/thunar-job-operation.h>
-#include <thunar/thunar-notify.h>
-#include <thunar/thunar-preferences.h>
 #include <thunar/thunar-private.h>
 
 /**
  * SECTION:thunar-job-operation
- * @Short_description: Manages the logging of job operations (copy, move etc.) and undoing and redoing them
+ * @Short_description: Stores a job operations (copy, move, trash, rename, etc.)
  * @Title: ThunarJobOperation
  *
  * The #ThunarJobOperation class represents a single 'job operation', a file operation like copying, moving
- * etc. that can be logged centrally and undone.
+ * trashing, renaming etc. and it's source/target locations.
  *
- * The @job_operation_list is a #GList of such job operations. It is not necessary that @job_operation_list
- * points to the head of the list; it points to the 'marked operation', the operation that reflects
- * the latest state of the operation history.
- * Usually, this will be the latest performed operation, which hasn't been undone yet.
  */
 
-static void                   thunar_job_operation_dispose            (GObject            *object);
 static void                   thunar_job_operation_finalize           (GObject            *object);
-static ThunarJobOperation    *thunar_job_operation_new_invert         (ThunarJobOperation *job_operation);
-static void                   thunar_job_operation_execute            (ThunarJobOperation *job_operation,
-                                                                       GError            **error);
 static gint                   thunar_job_operation_is_ancestor        (gconstpointer       descendant,
                                                                        gconstpointer       ancestor);
-static gint                   thunar_job_operation_compare            (ThunarJobOperation *operation1,
-                                                                       ThunarJobOperation *operation2);
 static void                   thunar_job_operation_restore_from_trash (ThunarJobOperation *operation,
                                                                        GError            **error);
 
@@ -60,7 +46,9 @@ struct _ThunarJobOperation
   ThunarJobOperationKind  operation_kind;
   GList                  *source_file_list;
   GList                  *target_file_list;
-  GList                  *overwritten_file_list;
+
+  /* Files overwritten as a part of an operation */
+  GList                  *overwritten_files_;
 
   /**
    * Optional timestampes (in seconds) which tell when the operation was started and ended.
@@ -72,29 +60,15 @@ struct _ThunarJobOperation
 
 G_DEFINE_TYPE (ThunarJobOperation, thunar_job_operation, G_TYPE_OBJECT)
 
-/* List of job operations which were logged */
-static GList *job_operation_list = NULL;
-static gint   job_operation_list_max_size;
 
-/* List pointer to the operation which can be undone */
-static GList *lp_undo_job_operation = NULL;
-
-/* List pointer to the operation which can be redone */
-static GList *lp_redo_job_operation = NULL;
 
 static void
 thunar_job_operation_class_init (ThunarJobOperationClass *klass)
 {
   GObjectClass      *gobject_class;
-  ThunarPreferences *preferences;
 
   gobject_class = G_OBJECT_CLASS (klass);
-  gobject_class->dispose = thunar_job_operation_dispose;
   gobject_class->finalize = thunar_job_operation_finalize;
-
-  preferences = thunar_preferences_get ();
-  g_object_get (G_OBJECT (preferences), "misc-undo-redo-history-size", &job_operation_list_max_size, NULL);
-  g_object_unref (preferences);
 }
 
 
@@ -105,13 +79,13 @@ thunar_job_operation_init (ThunarJobOperation *self)
   self->operation_kind = THUNAR_JOB_OPERATION_KIND_COPY;
   self->source_file_list = NULL;
   self->target_file_list = NULL;
-  self->overwritten_file_list = NULL;
+  self->overwritten_files_ = NULL;
 }
 
 
 
 static void
-thunar_job_operation_dispose (GObject *object)
+thunar_job_operation_finalize (GObject *object)
 {
   ThunarJobOperation *op;
 
@@ -119,16 +93,8 @@ thunar_job_operation_dispose (GObject *object)
 
   g_list_free_full (op->source_file_list, g_object_unref);
   g_list_free_full (op->target_file_list, g_object_unref);
-  g_list_free_full (op->overwritten_file_list, g_object_unref);
-
-  (*G_OBJECT_CLASS (thunar_job_operation_parent_class)->dispose) (object);
-}
-
+  g_list_free_full (op->overwritten_files_, g_object_unref);
 
-
-static void
-thunar_job_operation_finalize (GObject *object)
-{
   (*G_OBJECT_CLASS (thunar_job_operation_parent_class)->finalize) (object);
 }
 
@@ -208,304 +174,132 @@ thunar_job_operation_overwrite (ThunarJobOperation *job_operation,
 {
   _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION (job_operation));
 
-  job_operation->overwritten_file_list = thunar_g_list_append_deep (job_operation->overwritten_file_list, overwritten_file);
+  job_operation->overwritten_files_ = thunar_g_list_append_deep (job_operation->overwritten_files_, overwritten_file);
 }
 
 
 
 /**
- * thunar_job_operation_commit:
+ * thunar_job_operation_get_timestamps:
  * @job_operation: a #ThunarJobOperation
+ * @start_timestamp: Will be set to the current start_timestamp of the #ThunarJobOperation
+ * @end_timestamp: Will be set to the current end_timestamp of the #ThunarJobOperation
  *
- * Commits, or registers, the given thunar_job_operation, adding the job operation
- * to the job operation list.
+ * Getter for both timestamps
  **/
 void
-thunar_job_operation_commit (ThunarJobOperation *job_operation)
+thunar_job_operation_get_timestamps (ThunarJobOperation *job_operation,
+                                     gint64             *start_timestamp,
+                                     gint64             *end_timestamp)
 {
   _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION (job_operation));
 
-  if (job_operation->operation_kind == THUNAR_JOB_OPERATION_KIND_TRASH)
-    {
-      /* set the timestamp for the operation, in seconds. g_get_real_time gives
-       * us the time in microseconds, so we need to divide by 1e6. */
-      job_operation->end_timestamp = g_get_real_time () / (gint64) 1e6;
-    }
-
-  /* When a new operation is added, drop all previous operations which where undone from the list */
-  if (lp_redo_job_operation != NULL)
-    {
-      GList* new_list = NULL;
-      for (GList* lp = job_operation_list; lp != NULL && lp != lp_redo_job_operation; lp = lp->next)
-        new_list = g_list_append (new_list, g_object_ref (lp->data));
-      g_list_free_full (job_operation_list, g_object_unref);
-      job_operation_list = new_list;
-    }
-
-  /* Add the new operation to our list */
-  job_operation_list = g_list_append (job_operation_list, g_object_ref (job_operation));
-
-  /* reset the undo pointer to latest operation and clear the redo pointer */
-  lp_undo_job_operation = g_list_last (job_operation_list);
-  lp_redo_job_operation = NULL;
-
-  /* Limit the size of the list */
-  if (job_operation_list_max_size != -1 && g_list_length (job_operation_list) > (guint)job_operation_list_max_size)
-    {
-      GList* first = g_list_first (job_operation_list);
-      job_operation_list = g_list_remove_link (job_operation_list, first);
-      g_list_free_full (first, g_object_unref);
-    }
+  if (start_timestamp != NULL)
+    *start_timestamp = job_operation->start_timestamp;
+  if (end_timestamp != NULL)
+    *end_timestamp = job_operation->end_timestamp;
 }
 
 
 
 /**
- * thunar_job_operation_update_trash_timestamps:
+ * thunar_job_operation_set_start_timestamp:
  * @job_operation: a #ThunarJobOperation
+ * @start_timestamp: the new start_timestamp of the #ThunarJobOperation
  *
- * Only updates the timestamps of the latest trash operation
- * That is needed after 'redo' of a 'trash' operation,
- * since it requires to set new timestamps (otherwise 'undo' of that operation wont work afterwards)
+ * Setter for start_timestamp
  **/
 void
-thunar_job_operation_update_trash_timestamps (ThunarJobOperation *job_operation)
+thunar_job_operation_set_start_timestamp (ThunarJobOperation *job_operation,
+                                          gint64              start_timestamp)
 {
   _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION (job_operation));
 
-  if (job_operation->operation_kind != THUNAR_JOB_OPERATION_KIND_TRASH)
-    return;
-
-  if (lp_undo_job_operation == NULL)
-    return;
-
-  if (thunar_job_operation_compare ( THUNAR_JOB_OPERATION (lp_undo_job_operation->data), job_operation) == 0)
-    {
-      THUNAR_JOB_OPERATION (lp_undo_job_operation->data)->start_timestamp = job_operation->start_timestamp;
-
-      /* set the timestamp for the operation, in seconds. g_get_real_time gives
-       * us the time in microseconds, so we need to divide by 1e6. */
-      THUNAR_JOB_OPERATION (lp_undo_job_operation->data)->end_timestamp = g_get_real_time () / (gint64) 1e6;
-    }
+  job_operation->start_timestamp = start_timestamp;
 }
 
 
 
-/* thunar_job_operation_get_kind_nick:
- * @job_operation: A #ThunarJobOperation
- *
- * Get the nick name of the operation's kind in string format.
- * The string returned should NOT be freed.
+/**
+ * thunar_job_operation_set_end_timestamp:
+ * @job_operation: a #ThunarJobOperation
+ * @start_timestamp: the new end_timestamp of the #ThunarJobOperation
  *
- * Return value: A string containing the nick name of the job operation's kind
+ * Setter for end_timestamp
  **/
-const gchar *
-thunar_job_operation_get_kind_nick (ThunarJobOperation *job_operation)
+void
+thunar_job_operation_set_end_timestamp (ThunarJobOperation *job_operation,
+                                        gint64              end_timestamp)
 {
-  GEnumClass         *enum_class;
-  GEnumValue         *enum_value;
-
-  /* the enum value of the operation kind, which will be used to get its nick name */
-  enum_class = g_type_class_ref (THUNAR_TYPE_JOB_OPERATION_KIND);
-  enum_value = g_enum_get_value (enum_class, job_operation->operation_kind);
+  _thunar_return_if_fail (THUNAR_IS_JOB_OPERATION (job_operation));
 
-  return enum_value->value_nick;
+  job_operation->end_timestamp = end_timestamp;
 }
 
 
 
-/**
- * thunar_job_operation_undo:
+/* thunar_job_operation_get_kind:
+ * @job_operation: A #ThunarJobOperation
+ *
+ * Get the kind of the operation
  *
- * Undoes the latest job operation, by executing its inverse
+ * Return value: The kind of the operation
  **/
-void
-thunar_job_operation_undo (void)
+ThunarJobOperationKind
+thunar_job_operation_get_kind (ThunarJobOperation *job_operation)
 {
-  ThunarJobOperation *operation_marker;
-  ThunarJobOperation *inverted_operation;
-  GString            *warning_body;
-  gchar              *file_uri;
-  GError             *err = NULL;
-
-  /* Show a warning in case there is no operation to undo */
-  if (lp_undo_job_operation == NULL)
-    {
-      xfce_dialog_show_warning (NULL,
-                                _("No operation which can be undone has been performed yet.\n"
-                                  "(For some operations undo is not supported)"),
-                                _("There is no operation to undo"));
-      return;
-    }
-
-  /* the 'marked' operation */
-  operation_marker = lp_undo_job_operation->data;
-
-  /* fix position undo/redo pointers */
-  lp_redo_job_operation = lp_undo_job_operation;
-  lp_undo_job_operation = g_list_previous (lp_undo_job_operation);
-
-  /* warn the user if the previous operation is empty, since then there is nothing to undo */
-  if (operation_marker->source_file_list == NULL && operation_marker->target_file_list == NULL)
-    {
-
-      xfce_dialog_show_warning (NULL,
-                                _("The operation you are trying to undo does not have any files "
-                                  "associated with it, and thus cannot be undone. "),
-                                _("%s operation cannot be undone"), thunar_job_operation_get_kind_nick (operation_marker));
-      return;
-    }
-
-    /* if there were files overwritten in the operation, warn about them */
-    if (operation_marker->overwritten_file_list != NULL)
-      {
-        gint index;
-
-        index = 1; /* one indexed for the dialog */
-        warning_body = g_string_new (_("The following files were overwritten in the operation "
-                                       "you are trying to undo and cannot be restored:\n"));
-
-        for (GList *lp = operation_marker->overwritten_file_list; lp != NULL; lp = lp->next, index++)
-          {
-            file_uri = g_file_get_uri (lp->data);
-            g_string_append_printf (warning_body, "%d. %s\n", index, file_uri);
-            g_free (file_uri);
-          }
-
-        xfce_dialog_show_warning (NULL,
-                                  warning_body->str,
-                                  _("%s operation can only be partially undone"),
-                                  thunar_job_operation_get_kind_nick (operation_marker));
-
-        g_string_free (warning_body, TRUE);
-      }
-
-    inverted_operation = thunar_job_operation_new_invert (operation_marker);
-    thunar_job_operation_execute (inverted_operation, &err);
-    g_object_unref (inverted_operation);
-
-    if (err == NULL)
-      thunar_notify_undo (operation_marker);
+  _thunar_return_val_if_fail (THUNAR_IS_JOB_OPERATION (job_operation), THUNAR_JOB_OPERATION_KIND_COPY);
+   return job_operation->operation_kind;
 }
 
 
 
-/**
- * thunar_job_operation_redo:
+/* thunar_job_operation_get_overwritten_files:
+ * @job_operation: A #ThunarJobOperation
+ *
+ * Get the overwritten_files of the operation
  *
- * Redoes the last job operation which had been undone (if any)
+ * Return value: The overwritten_files of the operation
  **/
-void
-thunar_job_operation_redo (void)
+const GList*
+thunar_job_operation_get_overwritten_files (ThunarJobOperation *job_operation)
 {
-  ThunarJobOperation *operation_marker;
-  GString            *warning_body;
-  gchar              *file_uri;
-  GError             *err = NULL;
-
-  /* Show a warning in case there is no operation to undo */
-  if (lp_redo_job_operation == NULL)
-    {
-      xfce_dialog_show_warning (NULL,
-                                _("No operation which can be redone available.\n"),
-                                _("There is no operation to redo"));
-      return;
-    }
-
-  /* the 'marked' operation */
-  operation_marker = lp_redo_job_operation->data;
-
-  /* fix position undo/redo pointers */
-  lp_undo_job_operation = lp_redo_job_operation;
-  lp_redo_job_operation = g_list_next (lp_redo_job_operation);
-
-  /* warn the user if the previous operation is empty, since then there is nothing to undo */
-  if (operation_marker->source_file_list == NULL && operation_marker->target_file_list == NULL)
-    {
-
-      xfce_dialog_show_warning (NULL,
-                                _("The operation you are trying to redo does not have any files "
-                                  "associated with it, and thus cannot be redone. "),
-                                _("%s operation cannot be redone"), thunar_job_operation_get_kind_nick (operation_marker));
-      return;
-    }
-
-    /* if there were files overwritten in the operation, warn about them */
-    if (operation_marker->overwritten_file_list != NULL)
-      {
-        gint index;
-
-        index = 1; /* one indexed for the dialog */
-        warning_body = g_string_new (_("The following files were overwritten in the operation "
-                                       "you are trying to redo and cannot be restored:\n"));
-
-        for (GList *lp = operation_marker->overwritten_file_list; lp != NULL; lp = lp->next, index++)
-          {
-            file_uri = g_file_get_uri (lp->data);
-            g_string_append_printf (warning_body, "%d. %s\n", index, file_uri);
-            g_free (file_uri);
-          }
-
-        xfce_dialog_show_warning (NULL,
-                                  warning_body->str,
-                                  _("%s operation can only be partially redone"),
-                                  thunar_job_operation_get_kind_nick (operation_marker));
-
-        g_string_free (warning_body, TRUE);
-      }
-
-    thunar_job_operation_execute (operation_marker, &err);
-
-    if (err == NULL)
-      thunar_notify_redo (operation_marker);
+  _thunar_return_val_if_fail (THUNAR_IS_JOB_OPERATION (job_operation), NULL);
+   return job_operation->overwritten_files_;
 }
 
 
 
-/* thunar_job_operation_can_undo:
- *
- * Returns whether or not there is an operation on the job operation list that can be undone.
- *
- * Return value: A gboolean representing whether or not there is an undoable operation
- **/
 gboolean
-thunar_job_operation_can_undo (void)
+thunar_job_operation_empty (ThunarJobOperation *job_operation)
 {
-  ThunarJobOperation *operation_marker;
+  _thunar_return_val_if_fail (THUNAR_IS_JOB_OPERATION (job_operation), TRUE);
 
-  if (lp_undo_job_operation == NULL)
-    return FALSE;
- 
-  operation_marker = lp_undo_job_operation->data;
+  if (job_operation->source_file_list == NULL && job_operation->target_file_list == NULL)
+    return TRUE;
 
-  if (operation_marker->source_file_list == NULL && operation_marker->target_file_list == NULL)
-    return FALSE;
-
-  return TRUE;
+  return FALSE;
 }
 
-
-
-/* thunar_job_operation_can_redo:
+/* thunar_job_operation_get_kind_nick:
+ * @job_operation: A #ThunarJobOperation
  *
- * Returns whether or not there is an operation on the job operation list that can be redone.
+ * Get the nick name of the operation's kind in string format.
+ * The string returned should NOT be freed.
  *
- * Return value: A gboolean representing whether or not there is an redoable operation
+ * Return value: A string containing the nick name of the job operation's kind
  **/
-gboolean
-thunar_job_operation_can_redo (void)
+const gchar *
+thunar_job_operation_get_kind_nick (ThunarJobOperation *job_operation)
 {
-  ThunarJobOperation *operation_marker;
-
-  if (lp_redo_job_operation == NULL)
-    return FALSE;
-
-  operation_marker = lp_redo_job_operation->data;
+  GEnumClass         *enum_class;
+  GEnumValue         *enum_value;
 
-  if (operation_marker->source_file_list == NULL && operation_marker->target_file_list == NULL)
-    return FALSE;
+  /* the enum value of the operation kind, which will be used to get its nick name */
+  enum_class = g_type_class_ref (THUNAR_TYPE_JOB_OPERATION_KIND);
+  enum_value = g_enum_get_value (enum_class, job_operation->operation_kind);
 
-  return TRUE;
+  return enum_value->value_nick;
 }
 
 
@@ -585,7 +379,7 @@ thunar_job_operation_new_invert (ThunarJobOperation *job_operation)
  *
  * Executes the given @job_operation, depending on what kind of an operation it is.
  **/
-static void
+void
 thunar_job_operation_execute (ThunarJobOperation *job_operation,
                               GError            **error)
 {
@@ -733,7 +527,7 @@ thunar_job_operation_execute (ThunarJobOperation *job_operation,
       case THUNAR_JOB_OPERATION_KIND_TRASH:
         /* Special case: 'THUNAR_JOB_OPERATION_KIND_TRASH' only can be triggered by redo */
         /* Since we as well need to update the timestamps, we have to use THUNAR_OPERATION_LOG_ONLY_TIMESTAMPS */
-        /* 'thunar_job_operation_update_trash_timestamps' will then take care on update the existing job operation instead of adding a new one */
+        /* 'thunar_job_operation_history_update_trash_timestamps' will then take care on update the existing job operation instead of adding a new one */
         thunar_application_trash (application, NULL,
                                   job_operation->source_file_list,
                                   THUNAR_OPERATION_LOG_ONLY_TIMESTAMPS);
@@ -791,7 +585,7 @@ thunar_job_operation_is_ancestor (gconstpointer ancestor,
  * Return value: %0 if both operations match
  *               %1 otherwise
  **/
-static gint
+gint
 thunar_job_operation_compare (ThunarJobOperation *operation1,
                               ThunarJobOperation *operation2)
 {
diff --git a/thunar/thunar-job-operation.h b/thunar/thunar-job-operation.h
index a5c5e842..3cc5afb4 100644
--- a/thunar/thunar-job-operation.h
+++ b/thunar/thunar-job-operation.h
@@ -19,7 +19,7 @@
 #ifndef __THUNAR_JOB_OPERATION_H__
 #define __THUNAR_JOB_OPERATION_H__
 
-#include <gio/gio.h>
+#include <glib.h>
 #include <thunar/thunar-enum-types.h>
 
 G_BEGIN_DECLS
@@ -27,19 +27,29 @@ G_BEGIN_DECLS
 #define THUNAR_TYPE_JOB_OPERATION (thunar_job_operation_get_type ())
 G_DECLARE_FINAL_TYPE (ThunarJobOperation, thunar_job_operation, THUNAR, JOB_OPERATION, GObject)
 
-ThunarJobOperation    *thunar_job_operation_new                     (ThunarJobOperationKind kind);
-void                   thunar_job_operation_add                     (ThunarJobOperation    *job_operation,
-                                                                     GFile                 *source_file,
-                                                                     GFile                 *target_file);
-void                   thunar_job_operation_overwrite               (ThunarJobOperation    *job_operation,
-                                                                     GFile                 *overwritten_file);
-void                   thunar_job_operation_commit                  (ThunarJobOperation    *job_operation);
-void                   thunar_job_operation_update_trash_timestamps (ThunarJobOperation    *job_operation);
-const gchar           *thunar_job_operation_get_kind_nick           (ThunarJobOperation    *job_operation);
-void                   thunar_job_operation_undo                    (void);
-void                   thunar_job_operation_redo                    (void);
-gboolean               thunar_job_operation_can_undo                (void);
-gboolean               thunar_job_operation_can_redo                (void);
+ThunarJobOperation     *thunar_job_operation_new                   (ThunarJobOperationKind kind);
+void                    thunar_job_operation_add                   (ThunarJobOperation    *job_operation,
+                                                                    GFile                 *source_file,
+                                                                    GFile                 *target_file);
+void                    thunar_job_operation_overwrite             (ThunarJobOperation    *job_operation,
+                                                                    GFile                 *overwritten_file);
+ThunarJobOperation     *thunar_job_operation_new_invert            (ThunarJobOperation    *job_operation);
+void                    thunar_job_operation_execute               (ThunarJobOperation    *job_operation,
+                                                                    GError               **error);
+gint                    thunar_job_operation_compare               (ThunarJobOperation    *operation1,
+                                                                    ThunarJobOperation    *operation2);
+void                    thunar_job_operation_get_timestamps        (ThunarJobOperation    *job_operation,
+                                                                    gint64                *start_timestamp,
+                                                                    gint64                *end_timestamp);
+void                    thunar_job_operation_set_start_timestamp   (ThunarJobOperation    *job_operation,
+                                                                    gint64                 start_timestamp);
+void                    thunar_job_operation_set_end_timestamp     (ThunarJobOperation    *job_operation,
+                                                                    gint64                 end_timestamp);
+const gchar            *thunar_job_operation_get_kind_nick         (ThunarJobOperation    *job_operation);
+ThunarJobOperationKind  thunar_job_operation_get_kind              (ThunarJobOperation    *job_operation);
+const GList            *thunar_job_operation_get_overwritten_files (ThunarJobOperation    *job_operation);
+gboolean                thunar_job_operation_empty                 (ThunarJobOperation    *job_operation);
+
 
 G_END_DECLS
 
diff --git a/thunar/thunar-job.h b/thunar/thunar-job.h
index 36f8e54c..9f5b5ae2 100644
--- a/thunar/thunar-job.h
+++ b/thunar/thunar-job.h
@@ -28,7 +28,7 @@
 
 #include <thunar/thunar-enum-types.h>
 #include <thunar/thunar-file.h>
-#include <thunar/thunar-job-operation.h>
+#include <thunar/thunar-job-operation-history.h>
 
 G_BEGIN_DECLS
 
diff --git a/thunar/thunar-notify.h b/thunar/thunar-notify.h
index e5092dfa..0a042ca6 100644
--- a/thunar/thunar-notify.h
+++ b/thunar/thunar-notify.h
@@ -23,7 +23,7 @@
 
 #include <glib.h>
 #include <thunar/thunar-device.h>
-#include <thunar/thunar-job-operation.h>
+#include <thunar/thunar-job-operation-history.h>
 
 G_BEGIN_DECLS
 
diff --git a/thunar/thunar-transfer-job.c b/thunar/thunar-transfer-job.c
index c0788b21..0666c14a 100644
--- a/thunar/thunar-transfer-job.c
+++ b/thunar/thunar-transfer-job.c
@@ -30,7 +30,7 @@
 #include <thunar/thunar-io-scan-directory.h>
 #include <thunar/thunar-io-jobs-util.h>
 #include <thunar/thunar-job.h>
-#include <thunar/thunar-job-operation.h>
+#include <thunar/thunar-job-operation-history.h>
 #include <thunar/thunar-preferences.h>
 #include <thunar/thunar-private.h>
 #include <thunar/thunar-thumbnail-cache.h>
@@ -1721,7 +1721,7 @@ thunar_transfer_job_execute (ExoJob  *job,
        * in a mutually exclusive way, so we know that only one operation was created. */
       if (log_operations)
         {
-          thunar_job_operation_commit (operation);
+          thunar_job_operation_history_commit (operation);
           g_object_unref (operation);
         }
 
diff --git a/thunar/thunar-window.c b/thunar/thunar-window.c
index bdb0b0d6..6f6c4be7 100644
--- a/thunar/thunar-window.c
+++ b/thunar/thunar-window.c
@@ -47,7 +47,7 @@
 #include <thunar/thunar-gtk-extensions.h>
 #include <thunar/thunar-history.h>
 #include <thunar/thunar-icon-view.h>
-#include <thunar/thunar-job-operation.h>
+#include <thunar/thunar-job-operation-history.h>
 #include <thunar/thunar-location-buttons.h>
 #include <thunar/thunar-location-entry.h>
 #include <thunar/thunar-marshal.h>
@@ -381,102 +381,105 @@ struct _ThunarWindow
   GtkWindow __parent__;
 
   /* support for custom preferences actions */
-  ThunarxProviderFactory *provider_factory;
-  GList                  *thunarx_preferences_providers;
+  ThunarxProviderFactory    *provider_factory;
+  GList                     *thunarx_preferences_providers;
 
-  GFile                  *bookmark_file;
-  GList                  *bookmarks;
-  GFileMonitor           *bookmark_monitor;
+  GFile                     *bookmark_file;
+  GList                     *bookmarks;
+  GFileMonitor              *bookmark_monitor;
 
-  ThunarClipboardManager *clipboard;
+  ThunarClipboardManager   *clipboard;
 
-  ThunarPreferences      *preferences;
+  ThunarPreferences         *preferences;
 
   /* to be able to change folder on "device-pre-unmount" if required */
-  ThunarDeviceMonitor    *device_monitor;
-
-  GtkWidget              *grid;
-  GtkWidget              *menubar;
-  gboolean                menubar_visible;
-  GtkWidget              *spinner;
-  GtkWidget              *paned;
-  GtkWidget              *paned_right;
-  GtkWidget              *sidepane_box;
-  GtkWidget              *sidepane;
-  GtkWidget              *sidepane_preview_image;
-  GtkWidget              *right_pane_box;
-  GtkWidget              *right_pane_grid;
-  GtkWidget              *right_pane_preview_image;
-  GtkWidget              *right_pane_image_label;
-  GtkWidget              *right_pane_size_label;
-  GtkWidget              *view_box;
-  GtkWidget              *trash_infobar;
-  GtkWidget              *trash_infobar_restore_button;
-  GtkWidget              *trash_infobar_empty_button;
+  ThunarDeviceMonitor       *device_monitor;
+
+  GtkWidget                 *grid;
+  GtkWidget                 *menubar;
+  gboolean                   menubar_visible;
+  GtkWidget                *spinner;
+  GtkWidget                 *paned;
+  GtkWidget                 *paned_right;
+  GtkWidget                 *sidepane_box;
+  GtkWidget                 *sidepane;
+  GtkWidget                 *sidepane_preview_image;
+  GtkWidget                 *right_pane_box;
+  GtkWidget                 *right_pane_grid;
+  GtkWidget                 *right_pane_preview_image;
+  GtkWidget                 *right_pane_image_label;
+  GtkWidget                 *right_pane_size_label;
+  GtkWidget                 *view_box;
+  GtkWidget                 *trash_infobar;
+  GtkWidget                 *trash_infobar_restore_button;
+  GtkWidget                 *trash_infobar_empty_button;
 
   /* split view panes */
-  GtkWidget              *paned_notebooks;
-  GtkWidget              *notebook_selected;
-  GtkWidget              *notebook_left;
-  GtkWidget              *notebook_right;
+  GtkWidget                 *paned_notebooks;
+  GtkWidget                 *notebook_selected;
+  GtkWidget                 *notebook_left;
+  GtkWidget                 *notebook_right;
 
-  GtkWidget              *view;
-  GtkWidget              *statusbar;
+  GtkWidget                 *view;
+  GtkWidget                 *statusbar;
 
   /* search */
-  GtkWidget              *catfish_search_button;
-  gchar                  *search_query;
-  gboolean                is_searching;
-  gboolean                ignore_next_search_update;
+  GtkWidget                 *catfish_search_button;
+  gchar                     *search_query;
+  gboolean                   is_searching;
+  gboolean                   ignore_next_search_update;
 
-  GType                   view_type;
-  GSList                 *view_bindings;
-  guint                   reset_view_type_idle_id;
+  GType                      view_type;
+  GSList                    *view_bindings;
+  guint                      reset_view_type_idle_id;
 
   /* support for two different styles of location bars */
-  GtkWidget              *location_bar;
-  GtkWidget              *location_toolbar;
-  GFileMonitor           *uca_file_monitor;
-  GFile                  *uca_file;
+  GtkWidget                 *location_bar;
+  GtkWidget                 *location_toolbar;
+  GFileMonitor              *uca_file_monitor;
+  GFile                     *uca_file;
 
   /* we need to maintain pointers to be able to toggle sensitivity */
-  GtkWidget              *location_toolbar_item_back;
-  GtkWidget              *location_toolbar_item_forward;
-  GtkWidget              *location_toolbar_item_parent;
-  GtkWidget              *location_toolbar_item_home;
-  GtkWidget              *location_toolbar_item_undo;
-  GtkWidget              *location_toolbar_item_redo;
-  GtkWidget              *location_toolbar_item_zoom_in;
-  GtkWidget              *location_toolbar_item_zoom_out;
-  GtkWidget              *location_toolbar_item_search;
-  GtkWidget              *location_toolbar_item_view_menubar;
+  GtkWidget                 *location_toolbar_item_back;
+  GtkWidget                 *location_toolbar_item_forward;
+  GtkWidget                 *location_toolbar_item_parent;
+  GtkWidget                 *location_toolbar_item_home;
+  GtkWidget                 *location_toolbar_item_undo;
+  GtkWidget                 *location_toolbar_item_redo;
+  GtkWidget                 *location_toolbar_item_zoom_in;
+  GtkWidget                 *location_toolbar_item_zoom_out;
+  GtkWidget                 *location_toolbar_item_search;
+  GtkWidget                 *location_toolbar_item_view_menubar;
 
-  ThunarActionManager    *action_mgr;
+  ThunarActionManager       *action_mgr;
 
-  gulong                  signal_handler_id_history_changed;
+  gulong                     signal_handler_id_history_changed;
 
-  ThunarFile             *current_directory;
-  GtkAccelGroup          *accel_group;
+  ThunarFile                *current_directory;
+  GtkAccelGroup             *accel_group;
 
   /* zoom-level support */
-  ThunarZoomLevel         zoom_level;
+  ThunarZoomLevel            zoom_level;
 
-  gboolean                show_hidden;
+  gboolean                   show_hidden;
 
-  gboolean                directory_specific_settings;
+  gboolean                   directory_specific_settings;
 
   /* support to remember window geometry */
-  guint                   save_geometry_timer_id;
+  guint                      save_geometry_timer_id;
 
   /* support to toggle side pane using F9,
    * see the toggle_sidepane() function.
    */
-  GType                   toggle_sidepane_type;
+  GType                      toggle_sidepane_type;
 
   /* Image Preview thumbnail generation */
-  ThunarThumbnailer      *thumbnailer;
-  guint                   thumbnail_request;
-  GdkPixbuf              *preview_image_pixbuf;
+  ThunarThumbnailer         *thumbnailer;
+  guint                      thumbnail_request;
+  GdkPixbuf                 *preview_image_pixbuf;
+
+  /* Reference to the global job operation history */
+  ThunarJobOperationHistory *job_operation_history;
 };
 
 
@@ -1079,6 +1082,9 @@ thunar_window_init (ThunarWindow *window)
 
   window->search_query = NULL;
   window->reset_view_type_idle_id = 0;
+
+  /* get a reference of the global job operation history */
+  window->job_operation_history = thunar_job_operation_history_get_default ();
 }
 
 
@@ -1292,9 +1298,9 @@ thunar_window_update_edit_menu (ThunarWindow *window,
   thunar_gtk_menu_clean (GTK_MENU (menu));
 
   gtk_menu_item = xfce_gtk_menu_item_new_from_action_entry (get_action_entry (THUNAR_WINDOW_ACTION_UNDO), G_OBJECT (window), GTK_MENU_SHELL (menu));
-  gtk_widget_set_sensitive (gtk_menu_item, thunar_job_operation_can_undo ());
+  gtk_widget_set_sensitive (gtk_menu_item, thunar_job_operation_history_can_undo ());
   gtk_menu_item = xfce_gtk_menu_item_new_from_action_entry (get_action_entry (THUNAR_WINDOW_ACTION_REDO), G_OBJECT (window), GTK_MENU_SHELL (menu));
-  gtk_widget_set_sensitive (gtk_menu_item, thunar_job_operation_can_redo ());
+  gtk_widget_set_sensitive (gtk_menu_item, thunar_job_operation_history_can_redo ());
   xfce_gtk_menu_append_separator (GTK_MENU_SHELL (menu));
 
   thunar_menu_add_sections (THUNAR_MENU (menu), THUNAR_MENU_SECTION_CUT
@@ -1609,6 +1615,8 @@ thunar_window_finalize (GObject *object)
   /* disconnect signal from GtkRecentManager */
   g_signal_handlers_disconnect_by_data (G_OBJECT (gtk_recent_manager_get_default()), window);
 
+  g_object_unref (window->job_operation_history);
+
   (*G_OBJECT_CLASS (thunar_window_parent_class)->finalize) (object);
 }
 
@@ -3510,7 +3518,7 @@ static gboolean
 thunar_window_action_undo (ThunarWindow *window,
                            GtkWidget    *menu_item)
 {
-  thunar_job_operation_undo ();
+  thunar_job_operation_history_undo ();
   return TRUE; /* return value required in case of shortcut activation, in order to signal that the accel key got handled */
 }
 
@@ -3520,7 +3528,7 @@ static gboolean
 thunar_window_action_redo (ThunarWindow *window,
                            GtkWidget    *menu_item)
 {
-  thunar_job_operation_redo ();
+  thunar_job_operation_history_redo ();
   return TRUE; /* return value required in case of shortcut activation, in order to signal that the accel key got handled */
 }
 
